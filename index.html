<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>çœ¼åŠ¨è¿½è¸ªæ•°æ®æ”¶é›†ç³»ç»Ÿ</title>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
    
    <script>
        // Firebase é…ç½®
        const firebaseConfig = {
            apiKey: "AIzaSyB6O5l6uZa-6sywCZTGRJx2CKPuq3KeBF0",
            authDomain: "index-9f58d.firebaseapp.com",
            projectId: "index-9f58d",
            storageBucket: "index-9f58d.firebasestorage.app",
            messagingSenderId: "718279245978",
            appId: "1:718279245978:web:93a9a07473ad8d3e6a5f23"
        };
        
        // åˆå§‹åŒ– Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        
        // ç”Ÿæˆå”¯ä¸€ä¼šè¯ID
        const sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        const userId = 'jingtianwei2002';
        console.log('ä¼šè¯ID:', sessionId);

        // åŠ¨æ€åŠ è½½WebGazer
        async function loadWebGazerScript() {
            const sources = [
                './webgazer.js',  
                './lib/webgazer.js', 
                'https://webgazer.cs.brown.edu/webgazer.js',
                'https://unpkg.com/webgazer@2.0.2/dist/webgazer.js'
            ];

            for (const source of sources) {
                try {
                    await new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = source;
                        script.onload = resolve;
                        script.onerror = () => reject(new Error(`æ— æ³•ä» ${source} åŠ è½½WebGazer`));
                        document.head.appendChild(script);
                    });
                    console.log(`WebGazerä» ${source} åŠ è½½æˆåŠŸ`);
                    return true;
                } catch (error) {
                    console.error(`å°è¯•åŠ è½½å¤±è´¥: ${error.message}`);
                }
            }
            return false;
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/heatmap.js/2.0.0/heatmap.min.js"></script>
    <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            font-family: Arial, sans-serif;
            background: #f0f0f0;
        }
        
        #heatmapContainer { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            pointer-events: none; 
            z-index: -1000;
            opacity: 0.7;
            display: none;
        }
        
        #plotting_canvas {
            position: fixed;
            top: 0;
            left: 0;
            cursor: crosshair;
            z-index: 900;
            pointer-events: none;
        }
        
        #content { 
            position: relative; 
            z-index: 1; 
            padding: 50px; 
            max-width: 800px;
            margin: 0 auto;
            background: white;
            margin-top: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        #statsPanel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.85);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 2000;
            min-width: 300px;
            font-size: 14px;
        }
        
        .stat-item {
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
        }
        
        .stat-value {
            font-weight: bold;
            color: #4CAF50;
        }
        
        #debugPanel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.9);
            color: #00ff00;
            padding: 15px;
            border-radius: 8px;
            z-index: 2000;
            max-width: 350px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            display: none;
        }
        
        .test-area {
            height: 150px;
            margin: 30px 0;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #ddd;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .test-area:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .area-blue { background: linear-gradient(135deg, #74b9ff, #0984e3); color: white; }
        .area-green { background: linear-gradient(135deg, #00b894, #00a085); color: white; }
        .area-orange { background: linear-gradient(135deg, #fdcb6e, #e17055); color: white; }
        
        .controls {
            text-align: center;
            margin: 30px 0;
        }
        
        .btn {
            background: #4CAF50;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 0 10px;
            font-size: 16px;
            transition: background 0.3s;
        }
        
        .btn:hover { background: #45a049; }
        .btn.danger { background: #f44336; }
        .btn.danger:hover { background: #da190b; }
        .btn:disabled { background: #ccc; cursor: not-allowed; }
        .btn.test { background: #2196F3; }
        .btn.test:hover { background: #1976D2; }
        .btn.toggle { background: #FF9800; }
        .btn.toggle:hover { background: #F57C00; }
        
        .status {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 10px 15px;
            border-radius: 20px;
            font-weight: bold;
            z-index: 2000;
        }
        
        .status.ready { background: #4CAF50; color: white; }
        .status.calibrating { background: #ff9800; color: white; }
        .status.error { background: #f44336; color: white; }
        .status.initializing { background: #2196F3; color: white; }
        .status.loading { background: #9C27B0; color: white; }
        
        .loading-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 0%;
            height: 4px;
            background: linear-gradient(90deg, #4CAF50, #2196F3);
            z-index: 3000;
            transition: width 0.3s ease;
        }
        
        #webgazerVideoContainer {
            position: fixed !important;
            top: 10px !important;
            right: 10px !important;
            z-index: 9999 !important;
            width: 240px !important;
            height: 180px !important;
        }
        
        #webgazerVideoFeed {
            width: 100% !important;
            height: 100% !important;
            border-radius: 8px !important;
            border: 2px solid #4CAF50 !important;
        }
        
        .Calibration {
            width: 20px;
            height: 20px;
            -webkit-border-radius: 25px;
            -moz-border-radius: 25px;
            border-radius: 25px;
            background-color: red;
            opacity: 0.2;
            border-color: black;
            border-style: solid;
            position: fixed;
            z-index: 99999;
            cursor: pointer;
        }
        
        #Pt1 { top: 10%; left: 10%; }
        #Pt2 { top: 10%; left: 50%; margin-left: -10px; }
        #Pt3 { top: 10%; right: 10%; }
        #Pt4 { top: 50%; margin-top: -10px; left: 10%; }
        #Pt5 { top: 50%; margin-top: -10px; left: 50%; margin-left: -10px; }
        #Pt6 { top: 50%; margin-top: -10px; right: 10%; }
        #Pt7 { bottom: 10%; left: 10%; }
        #Pt8 { bottom: 10%; left: 50%; margin-left: -10px; }
        #Pt9 { bottom: 10%; right: 10%; }
        
        #Accuracy {
            background-color: #222;
            color: white;
            padding: 10px;
            border-radius: 5px;
        }

        .collection-status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        .collection-status.connected { background: #4CAF50; color: white; }
        .collection-status.disconnected { background: #f44336; color: white; }
        .collection-status.uploading { background: #ff9800; color: white; }

        .firebase-status {
            margin-top: 10px;
            padding: 8px;
            border-radius: 4px;
            text-align: center;
            font-size: 12px;
        }

        .heatmap-visible {
            opacity: 0.7 !important;
            display: block !important;
        }
    </style>
</head>
<body>
    <div id="loadingBar" class="loading-bar"></div>
    <div id="status" class="status loading">æ­£åœ¨åŠ è½½åº“æ–‡ä»¶...</div>
    <canvas id="plotting_canvas" width="500" height="500"></canvas>

    <div id="statsPanel">
        <h3 style="margin-top: 0; color: #4CAF50;">ğŸ“Š çœ¼åŠ¨æ•°æ®ç»Ÿè®¡</h3>
        <div class="stat-item">
            <span>ä¼šè¯ID:</span>
            <span id="sessionIdDisplay" class="stat-value" style="font-size: 10px;"></span>
        </div>
        <div class="stat-item">
            <span>æ³¨è§†ç‚¹æ€»æ•°:</span>
            <span id="totalGazes" class="stat-value">0</span>
        </div>
        <div class="stat-item">
            <span>çœ¼è·³æ¬¡æ•°:</span>
            <span id="saccadeCount" class="stat-value">0</span>
        </div>
        <div class="stat-item">
            <span>æ³¨è§†æ¬¡æ•°:</span>
            <span id="fixationCount" class="stat-value">0</span>
        </div>
        <div class="stat-item">
            <span>å¹³å‡æ³¨è§†æ—¶é—´:</span>
            <span id="avgFixationTime" class="stat-value">0ms</span>
        </div>
        <div class="stat-item">
            <span>çƒ­åŠ›å›¾å¿«ç…§:</span>
            <span id="heatmapSnapshots" class="stat-value">0</span>
        </div>
        <div class="stat-item">
            <span>æ•°æ®å¿«ç…§æ•°:</span>
            <span id="snapshotCount" class="stat-value">0</span>
        </div>
        <div class="stat-item">
            <span>è¿è¡Œæ—¶é—´:</span>
            <span id="runningTime" class="stat-value">0ç§’</span>
        </div>
        <div id="Accuracy">ç­‰å¾…æ ¡å‡†...</div>
        <div class="stat-item">
            <span>ç³»ç»ŸçŠ¶æ€:</span>
            <span id="systemStatus" class="stat-value">åŠ è½½ä¸­</span>
        </div>
        <div class="collection-status disconnected" id="collectionStatus">
            ğŸ“ˆ æ•°æ®æ”¶é›†: æœªå¼€å§‹
        </div>
        <div class="firebase-status disconnected" id="firebaseStatus">
            ğŸ”¥ Firebase: æœªè¿æ¥
        </div>
        
        <button class="btn test" onclick="testFirebaseConnection()" style="width: 100%; margin-top: 10px; font-size: 12px;">
            ğŸ§ª æµ‹è¯•è¿æ¥
        </button>
        <button class="btn test" onclick="forceSaveData()" style="width: 100%; margin-top: 5px; font-size: 12px;">
            ğŸ’¾ å¼ºåˆ¶ä¿å­˜
        </button>
        <button class="btn toggle" onclick="toggleHeatmap()" style="width: 100%; margin-top: 5px; font-size: 12px;">
            ğŸ”¥ æ˜¾ç¤ºçƒ­åŠ›å›¾
        </button>
        <button class="btn test" onclick="toggleDebug()" style="width: 100%; margin-top: 5px; font-size: 12px;">
            ğŸ› æ˜¾ç¤ºè°ƒè¯•
        </button>
    </div>

    <div id="debugPanel">
        <div id="debugInfo">è°ƒè¯•ä¿¡æ¯å°†åœ¨è¿™é‡Œæ˜¾ç¤º...</div>
    </div>

    <div id="heatmapContainer"></div>

    <div class="calibrationDiv">
        <input type="button" class="Calibration" id="Pt1" style="display: none;">
        <input type="button" class="Calibration" id="Pt2" style="display: none;">
        <input type="button" class="Calibration" id="Pt3" style="display: none;">
        <input type="button" class="Calibration" id="Pt4" style="display: none;">
        <input type="button" class="Calibration" id="Pt5" style="display: none;">
        <input type="button" class="Calibration" id="Pt6" style="display: none;">
        <input type="button" class="Calibration" id="Pt7" style="display: none;">
        <input type="button" class="Calibration" id="Pt8" style="display: none;">
        <input type="button" class="Calibration" id="Pt9" style="display: none;">
    </div>

    <div id="content">
        <h1 style="text-align: center; color: #333;">ğŸ‘ï¸ çœ¼åŠ¨è¿½è¸ªæ•°æ®æ”¶é›†ç³»ç»Ÿ</h1>
        
        <div class="controls">
            <button class="btn" id="startBtn" onclick="startEyeTracking()">ğŸš€ å¯åŠ¨çœ¼åŠ¨è¿½è¸ª</button>
            <button class="btn" id="calibrateBtn" onclick="PopUpInstruction()" disabled>ğŸ¯ å¼€å§‹æ ¡å‡†</button>
            <button class="btn" onclick="Restart()">ğŸ”„ é‡æ–°æ ¡å‡†</button>
            <button class="btn" onclick="exportData()">ğŸ“Š å¯¼å‡ºæ•°æ®</button>
            <button class="btn danger" onclick="stopTracking()">â¹ï¸ åœæ­¢è¿½è¸ª</button>
        </div>
        
        <p style="text-align: center; font-size: 18px; color: #666; margin: 30px 0;">
            ğŸ‘€ è¯·è‡ªç„¶åœ°æµè§ˆä¸‹é¢çš„å†…å®¹ï¼Œç³»ç»Ÿä¼šæ”¶é›†æ‚¨çš„çœ¼åŠ¨æ•°æ®
        </p>
        
        <div class="test-area area-blue" data-region="content_area_a">
            <h2>ğŸŒŠ åŒºåŸŸ A - æµ·æ´‹è“</h2>
            <p>è¿™æ˜¯ç¬¬ä¸€ä¸ªæµ‹è¯•åŒºåŸŸã€‚è¯·å°è¯•æ³¨è§†è¿™é‡Œå‡ ç§’é’Ÿï¼Œç³»ç»Ÿä¼šè®°å½•æ‚¨çš„æ³¨è§†ç‚¹åæ ‡ã€æ³¨è§†æ—¶é—´å’Œçœ¼åŠ¨æ¨¡å¼ã€‚</p>
        </div>
        
        <div class="test-area area-green" data-region="content_area_b">
            <h2>ğŸŒ¿ åŒºåŸŸ B - æ£®æ—ç»¿</h2>
            <p>è¿™æ˜¯ç¬¬äºŒä¸ªæµ‹è¯•åŒºåŸŸã€‚åœ¨ä¸åŒåŒºåŸŸä¹‹é—´ç§»åŠ¨è§†çº¿ä¼šäº§ç”Ÿçœ¼è·³æ•°æ®ï¼ŒåŒ…æ‹¬ç§»åŠ¨è·ç¦»å’Œé€Ÿåº¦ã€‚</p>
        </div>
        
        <div class="test-area area-orange" data-region="content_area_c">
            <h2>ğŸ”¥ åŒºåŸŸ C - å¤•é˜³æ©™</h2>
            <p>è¿™æ˜¯ç¬¬ä¸‰ä¸ªæµ‹è¯•åŒºåŸŸã€‚é•¿æ—¶é—´æ³¨è§†ä¼šç”Ÿæˆæ³¨è§†æ•°æ®ï¼ŒåŒ…æ‹¬æ³¨è§†ä½ç½®å’ŒæŒç»­æ—¶é—´ã€‚ç³»ç»Ÿæ¯ç§’ä¼šç”Ÿæˆä¸€å¼ çƒ­åŠ›å›¾å¿«ç…§ä¿å­˜åˆ°Firebaseã€‚</p>
        </div>
        
        <div style="text-align: center; margin: 40px 0; padding: 20px; background: #e8f5e8; border-radius: 8px;">
            <h4 style="color: #2e7d32; margin-bottom: 15px;">ğŸ“‹ ä½¿ç”¨è¯´æ˜</h4>
            <p style="margin: 8px 0; color: #555;">1. ç‚¹å‡»"å¯åŠ¨çœ¼åŠ¨è¿½è¸ª"å¼€å§‹æ”¶é›†æ•°æ®</p>
            <p style="margin: 8px 0; color: #555;">2. å¯é€‰æ‹©å®Œæˆ9ç‚¹æ ¡å‡†æé«˜ç²¾åº¦</p>
            <p style="margin: 8px 0; color: #555;">3. è‡ªç„¶æµè§ˆé¡µé¢ï¼Œæ•°æ®è‡ªåŠ¨ä¿å­˜åˆ°äº‘ç«¯</p>
            <p style="margin: 8px 0; color: #555;">4. ç‚¹å‡»"æ˜¾ç¤ºçƒ­åŠ›å›¾"å¯æŸ¥çœ‹å®æ—¶çƒ­åŠ›å›¾</p>
        </div>
    </div>

    <script>
        // ===========================================
        // å…¨å±€å˜é‡å®šä¹‰
        // ===========================================
        let heatmapInstance = null;
        let gazeCount = 0;
        let saccadeCount = 0;
        let fixationCount = 0;
        let heatmapSnapshotCount = 0;
        let snapshotCount = 0;
        let totalDuration = 0;
        let startTime = Date.now();
        let isTracking = false;
        let webgazerReady = false;
        let debugMode = false;
        let heatmapVisible = false;
        let rawGazeCount = 0;
        let initializationAttempts = 0;
        let librariesLoaded = false;
        let lastGazeTime = 0;
        let firebaseConnected = false;
        
        // æ ¡å‡†ç›¸å…³å˜é‡
        var PointCalibrate = 0;
        var CalibrationPoints = {};

        // ç²¾åº¦è®¡ç®—ç›¸å…³å˜é‡
        var isStoring = false;
        var storedPoints = {x: [], y: []};

        // å®Œæ•´çš„çœ¼åŠ¨æ•°æ®ç»“æ„
        let eyeTrackingData = {
            gazePoints: [],
            saccades: [],
            fixations: [],
            heatmapSnapshots: [],
            statistics: {
                totalGazePoints: 0,
                totalSaccades: 0,
                totalFixations: 0,
                averageFixationDuration: 0,
                longestFixationDuration: 0,
                shortestFixationDuration: 0,
                totalViewingTime: 0,
                dataQuality: 0
            }
        };

        let sessionStartTime = new Date().toISOString();
        let lastGazePoint = null;
        let currentFixation = null;
        let autoSaveInterval = null;
        let heatmapSnapshotInterval = null;

        // çœ¼è·³æ£€æµ‹å‚æ•°
        const SACCADE_THRESHOLD = 100;
        const FIXATION_MIN_DURATION = 100;

        // æ˜¾ç¤ºä¼šè¯ID
        document.getElementById('sessionIdDisplay').textContent = sessionId.substring(0, 15) + '...';

        // ===========================================
        // Firebase æ•°æ®ä¿å­˜ç»“æ„
        // ===========================================
        
        function createCompleteFirebaseData() {
            const currentTime = new Date().toISOString();
            
            return {
                sessionInfo: {
                    sessionId: sessionId,
                    userId: userId,
                    timestamp: currentTime,
                    sessionStartTime: sessionStartTime,
                    duration: Math.round((Date.now() - startTime) / 1000),
                    snapshotNumber: snapshotCount + 1
                },
                
                deviceInfo: {
                    windowWidth: window.innerWidth,
                    windowHeight: window.innerHeight,
                    userAgent: navigator.userAgent,
                    timezone: "Asia/Shanghai"
                },
                
                eyeTrackingData: {
                    gazePoints: eyeTrackingData.gazePoints.map((point, index) => ({
                        id: index + 1,
                        x: point.x,
                        y: point.y,
                        timestamp: point.timestamp,
                        duration: point.duration,
                        confidence: point.confidence || 0.8,
                        sequence: index + 1
                    })),
                    
                    saccades: eyeTrackingData.saccades.map((saccade, index) => ({
                        id: index + 1,
                        fromX: saccade.fromX,
                        fromY: saccade.fromY,
                        toX: saccade.toX,
                        toY: saccade.toY,
                        distance: saccade.distance,
                        duration: saccade.duration,
                        velocity: saccade.velocity,
                        timestamp: saccade.timestamp,
                        sequence: index + 1
                    })),
                    
                    fixations: eyeTrackingData.fixations.map((fixation, index) => ({
                        id: index + 1,
                        x: fixation.x,
                        y: fixation.y,
                        duration: fixation.duration,
                        startTime: fixation.startTime,
                        endTime: fixation.endTime,
                        pointCount: fixation.pointCount,
                        stability: fixation.stability,
                        sequence: index + 1
                    })),
                    
                    heatmapData: {
                        snapshots: eyeTrackingData.heatmapSnapshots,
                        totalSnapshots: heatmapSnapshotCount,
                        lastSnapshot: eyeTrackingData.heatmapSnapshots[eyeTrackingData.heatmapSnapshots.length - 1] || null,
                        heatmapSettings: {
                            maxOpacity: 0.8,
                            minOpacity: 0.1,
                            blur: 0.85,
                            resolution: `${window.innerWidth}x${window.innerHeight}`
                        }
                    },
                    
                    statistics: {
                        gazePointsCount: gazeCount,
                        saccadesCount: saccadeCount,
                        fixationsCount: fixationCount,
                        averageFixationDuration: calculateAverageFixationDuration(),
                        longestFixationDuration: calculateLongestFixation(),
                        shortestFixationDuration: calculateShortestFixation(),
                        totalViewingTime: Math.round((Date.now() - startTime) / 1000),
                        dataQualityScore: calculateDataQuality(),
                        validDataRatio: gazeCount > 0 ? Math.round((gazeCount / rawGazeCount) * 100) : 0
                    }
                },
                
                calibrationInfo: {
                    completed: PointCalibrate >= 9,
                    pointsCalibrated: PointCalibrate,
                    accuracy: document.getElementById("Accuracy").textContent,
                    calibrationQuality: Math.round((PointCalibrate / 9) * 100)
                },
                
                systemStatus: {
                    webgazerReady: webgazerReady,
                    trackingActive: isTracking,
                    firebaseConnected: firebaseConnected,
                    librariesLoaded: librariesLoaded,
                    autoSaveActive: autoSaveInterval !== null
                }
            };
        }

        function generateHeatmapSnapshot() {
            if (!heatmapInstance || !heatmapInstance._store) {
                return null;
            }

            const heatmapData = heatmapInstance._store._data || [];
            const currentTime = new Date().toISOString();
            
            const snapshot = {
                timestamp: currentTime,
                snapshotId: heatmapSnapshotCount + 1,
                dataPoints: heatmapData.map(point => ({
                    x: Math.round(point.x),
                    y: Math.round(point.y),
                    value: Math.round(point.value * 100) / 100,
                    intensity: Math.round((point.value / (heatmapInstance._store.max || 100)) * 100)
                })),
                maxValue: Math.round((heatmapInstance._store.max || 0) * 100) / 100,
                totalPoints: heatmapData.length,
                windowSize: {
                    width: window.innerWidth,
                    height: window.innerHeight
                }
            };
            
            return snapshot;
        }

        // ===========================================
        // æ•°æ®è®¡ç®—å‡½æ•°
        // ===========================================
        
        function calculateAverageFixationDuration() {
            if (eyeTrackingData.fixations.length === 0) return 0;
            const total = eyeTrackingData.fixations.reduce((sum, fix) => sum + fix.duration, 0);
            return Math.round(total / eyeTrackingData.fixations.length);
        }

        function calculateLongestFixation() {
            if (eyeTrackingData.fixations.length === 0) return 0;
            return Math.max(...eyeTrackingData.fixations.map(fix => fix.duration));
        }

        function calculateShortestFixation() {
            if (eyeTrackingData.fixations.length === 0) return 0;
            return Math.min(...eyeTrackingData.fixations.map(fix => fix.duration));
        }

        function calculateDataQuality() {
            let score = 0;
            let factors = 0;
            
            if (gazeCount > 0) {
                score += Math.min(gazeCount / 100, 1) * 25;
                factors++;
            }
            
            if (PointCalibrate >= 9) {
                score += 25;
                factors++;
            } else if (PointCalibrate > 0) {
                score += (PointCalibrate / 9) * 25;
                factors++;
            }
            
            if (rawGazeCount > 0 && gazeCount > 0) {
                const continuity = (gazeCount / rawGazeCount) * 100;
                score += Math.min(continuity, 100) * 0.25;
                factors++;
            }
            
            if (eyeTrackingData.fixations.length > 0) {
                const avgStability = eyeTrackingData.fixations.reduce((sum, fix) => sum + (fix.stability || 0), 0) / eyeTrackingData.fixations.length;
                score += avgStability * 0.25;
                factors++;
            }
            
            return factors > 0 ? Math.round(score / factors) : 0;
        }

        function calculateSaccadeVelocity(distance, duration) {
            if (duration === 0) return 0;
            return Math.round((distance / duration) * 1000);
        }

        function calculateFixationStability(points) {
            if (points.length < 2) return 100;
            
            const centerX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
            const centerY = points.reduce((sum, p) => sum + p.y, 0) / points.length;
            
            let totalDeviation = 0;
            points.forEach(point => {
                const deviation = Math.sqrt(
                    Math.pow(point.x - centerX, 2) + Math.pow(point.y - centerY, 2)
                );
                totalDeviation += deviation;
            });
            
            const averageDeviation = totalDeviation / points.length;
            return Math.max(0, 100 - averageDeviation);
        }

        // ===========================================
        // Firebase è¿æ¥å’Œä¿å­˜
        // ===========================================
        
        async function testFirebaseConnection() {
            debug('å¼€å§‹æµ‹è¯•Firebaseè¿æ¥...');
            updateFirebaseStatus('æµ‹è¯•ä¸­...', 'uploading');
            
            try {
                const testDoc = await db.collection("connection_test").add({
                    test: true,
                    timestamp: new Date().toISOString(),
                    user: userId,
                    sessionId: sessionId
                });
                
                debug(`Firebaseè¿æ¥æµ‹è¯•æˆåŠŸï¼æ–‡æ¡£ID: ${testDoc.id}`);
                updateFirebaseStatus('è¿æ¥æ­£å¸¸', 'connected');
                firebaseConnected = true;
                
                const readTest = await db.collection("connection_test").doc(testDoc.id).get();
                if (readTest.exists) {
                    debug('Firebaseè¯»å–æµ‹è¯•æˆåŠŸï¼');
                    alert('ğŸ‰ Firebaseè¿æ¥æµ‹è¯•æˆåŠŸï¼\n\nâœ… å†™å…¥æµ‹è¯•é€šè¿‡\nâœ… è¯»å–æµ‹è¯•é€šè¿‡\n\nç°åœ¨å¯ä»¥æ­£å¸¸æ”¶é›†çœ¼åŠ¨æ•°æ®äº†ï¼');
                } else {
                    throw new Error('è¯»å–æµ‹è¯•å¤±è´¥');
                }
                
                return true;
            } catch (error) {
                debug(`Firebaseè¿æ¥æµ‹è¯•å¤±è´¥: ${error.message}`);
                updateFirebaseStatus('è¿æ¥å¤±è´¥', 'disconnected');
                firebaseConnected = false;
                alert(`âŒ Firebaseè¿æ¥æµ‹è¯•å¤±è´¥ï¼\n\n${error.message}`);
                return false;
            }
        }

        function updateFirebaseStatus(message, status) {
            const statusElement = document.getElementById('firebaseStatus');
            statusElement.textContent = `ğŸ”¥ Firebase: ${message}`;
            statusElement.className = `firebase-status ${status}`;
        }

        async function forceSaveData() {
            if (!firebaseConnected) {
                alert('âŒ è¯·å…ˆæµ‹è¯•Firebaseè¿æ¥ï¼');
                return;
            }
            
            debug('å¼ºåˆ¶ä¿å­˜å®Œæ•´çœ¼åŠ¨æ•°æ®...');
            
            try {
                const completeData = createCompleteFirebaseData();
                completeData.dataType = 'manual_force_save';
                completeData.note = 'æ‰‹åŠ¨å¼ºåˆ¶ä¿å­˜çš„å®Œæ•´çœ¼åŠ¨æ•°æ®';

                const docRef = await db.collection("eye_tracking_data").add(completeData);
                
                snapshotCount++;
                document.getElementById('snapshotCount').textContent = snapshotCount;
                
                debug(`å®Œæ•´æ•°æ®å¼ºåˆ¶ä¿å­˜æˆåŠŸï¼æ–‡æ¡£ID: ${docRef.id}`);
                
                const summary = `âœ… å®Œæ•´çœ¼åŠ¨æ•°æ®ä¿å­˜æˆåŠŸï¼

ğŸ“„ æ–‡æ¡£ID: ${docRef.id}
ğŸ“Š æ•°æ®è¯¦æƒ…:
â€¢ æ³¨è§†ç‚¹: ${gazeCount} ä¸ª
â€¢ çœ¼è·³: ${saccadeCount} æ¬¡  
â€¢ æ³¨è§†: ${fixationCount} æ¬¡
â€¢ å¹³å‡æ³¨è§†æ—¶é—´: ${calculateAverageFixationDuration()}ms
â€¢ çƒ­åŠ›å›¾å¿«ç…§: ${heatmapSnapshotCount} å¼ 
â€¢ æ•°æ®è´¨é‡: ${calculateDataQuality()}%

ğŸ” è¯·åˆ°Firebaseæ§åˆ¶å°æŸ¥çœ‹ eye_tracking_data é›†åˆï¼`;
                
                alert(summary);
                
            } catch (error) {
                debug(`å¼ºåˆ¶ä¿å­˜å¤±è´¥: ${error.message}`);
                alert(`âŒ ä¿å­˜å¤±è´¥ï¼\n\n${error.message}`);
            }
        }

        // ===========================================
        // è‡ªåŠ¨ä¿å­˜åŠŸèƒ½
        // ===========================================
        
        function startAutoSave() {
            if (autoSaveInterval) {
                clearInterval(autoSaveInterval);
            }
            
            autoSaveInterval = setInterval(async () => {
                if (isTracking && firebaseConnected) {
                    await saveCompleteEyeTrackingData();
                }
            }, 1000);
            
            if (heatmapSnapshotInterval) {
                clearInterval(heatmapSnapshotInterval);
            }
            
            heatmapSnapshotInterval = setInterval(() => {
                if (isTracking && heatmapInstance) {
                    const snapshot = generateHeatmapSnapshot();
                    if (snapshot && snapshot.dataPoints.length > 0) {
                        eyeTrackingData.heatmapSnapshots.push(snapshot);
                        heatmapSnapshotCount++;
                        document.getElementById('heatmapSnapshots').textContent = heatmapSnapshotCount;
                        debug(`çƒ­åŠ›å›¾å¿«ç…§ #${heatmapSnapshotCount} å·²ç”Ÿæˆ: ${snapshot.dataPoints.length} ä¸ªç‚¹`);
                    }
                }
            }, 1000);
            
            updateCollectionStatus('è¿›è¡Œä¸­ (æ¯ç§’ä¿å­˜)', 'connected');
            debug('è‡ªåŠ¨ä¿å­˜å·²å¯åŠ¨ï¼šæ•°æ®æ¯ç§’ä¿å­˜ï¼Œçƒ­åŠ›å›¾æ¯ç§’ç”Ÿæˆå¿«ç…§');
        }

        function stopAutoSave() {
            if (autoSaveInterval) {
                clearInterval(autoSaveInterval);
                autoSaveInterval = null;
            }
            
            if (heatmapSnapshotInterval) {
                clearInterval(heatmapSnapshotInterval);
                heatmapSnapshotInterval = null;
            }
            
            updateCollectionStatus('å·²åœæ­¢', 'disconnected');
            debug('è‡ªåŠ¨ä¿å­˜å·²åœæ­¢');
        }

        function updateCollectionStatus(message, status) {
            const statusElement = document.getElementById('collectionStatus');
            statusElement.textContent = `ğŸ“ˆ æ•°æ®æ”¶é›†: ${message}`;
            statusElement.className = `collection-status ${status}`;
        }

        async function saveCompleteEyeTrackingData() {
            if (!firebaseConnected) {
                return;
            }
            
            try {
                updateCollectionStatus('ä¿å­˜ä¸­...', 'uploading');
                
                const completeData = createCompleteFirebaseData();
                completeData.dataType = 'automatic_snapshot';

                const docRef = await db.collection("eye_tracking_data").add(completeData);
                
                snapshotCount++;
                document.getElementById('snapshotCount').textContent = snapshotCount;
                
                debug(`å®Œæ•´æ•°æ®å¿«ç…§ #${snapshotCount} å·²ä¿å­˜: æ³¨è§†ç‚¹${eyeTrackingData.gazePoints.length}, çœ¼è·³${eyeTrackingData.saccades.length}, æ³¨è§†${eyeTrackingData.fixations.length}, çƒ­åŠ›å›¾${eyeTrackingData.heatmapSnapshots.length}`);
                
                eyeTrackingData.gazePoints = [];
                eyeTrackingData.saccades = [];
                
                updateCollectionStatus('è¿›è¡Œä¸­ (æ¯ç§’ä¿å­˜)', 'connected');
                
            } catch (error) {
                debug(`æ•°æ®ä¿å­˜å¤±è´¥: ${error.message}`);
                updateCollectionStatus('ä¿å­˜å¤±è´¥', 'disconnected');
                console.error('ä¿å­˜é”™è¯¯:', error);
            }
        }

        // ===========================================
        // çœ¼åŠ¨æ•°æ®å¤„ç†
        // ===========================================
        
        function detectSaccade(currentPoint, previousPoint) {
            if (!previousPoint || !currentPoint) return false;
            
            const distance = Math.sqrt(
                Math.pow(currentPoint.x - previousPoint.x, 2) + 
                Math.pow(currentPoint.y - previousPoint.y, 2)
            );
            
            return distance > SACCADE_THRESHOLD;
        }

        function processFixation(gazePoint) {
            const currentTime = Date.now();
            
            if (!currentFixation) {
                currentFixation = {
                    startTime: currentTime,
                    x: gazePoint.x,
                    y: gazePoint.y,
                    points: [gazePoint]
                };
            } else {
                const distance = Math.sqrt(
                    Math.pow(gazePoint.x - currentFixation.x, 2) + 
                    Math.pow(gazePoint.y - currentFixation.y, 2)
                );
                
                if (distance < SACCADE_THRESHOLD) {
                    currentFixation.points.push(gazePoint);
                    const avgX = currentFixation.points.reduce((sum, p) => sum + p.x, 0) / currentFixation.points.length;
                    const avgY = currentFixation.points.reduce((sum, p) => sum + p.y, 0) / currentFixation.points.length;
                    currentFixation.x = avgX;
                    currentFixation.y = avgY;
                } else {
                    const duration = currentTime - currentFixation.startTime;
                    if (duration >= FIXATION_MIN_DURATION) {
                        const stability = calculateFixationStability(currentFixation.points);
                        
                        const fixationData = {
                            x: Math.round(currentFixation.x),
                            y: Math.round(currentFixation.y),
                            duration: duration,
                            startTime: new Date(currentFixation.startTime).toISOString(),
                            endTime: new Date(currentTime).toISOString(),
                            pointCount: currentFixation.points.length,
                            stability: Math.round(stability)
                        };
                        
                        eyeTrackingData.fixations.push(fixationData);
                        fixationCount++;
                        document.getElementById('fixationCount').textContent = fixationCount;
                        
                        const avgTime = calculateAverageFixationDuration();
                        document.getElementById('avgFixationTime').textContent = avgTime + 'ms';
                    }
                    
                    currentFixation = {
                        startTime: currentTime,
                        x: gazePoint.x,
                        y: gazePoint.y,
                        points: [gazePoint]
                    };
                }
            }
        }

        // ===========================================
        // çƒ­åŠ›å›¾æ§åˆ¶
        // ===========================================
        
        function toggleHeatmap() {
            heatmapVisible = !heatmapVisible;
            const container = document.getElementById('heatmapContainer');
            const button = event.target;
            
            if (heatmapVisible) {
                container.classList.add('heatmap-visible');
                button.textContent = 'ğŸ”¥ éšè—çƒ­åŠ›å›¾';
                button.style.background = '#FF5722';
                debug('çƒ­åŠ›å›¾å·²æ˜¾ç¤º');
            } else {
                container.classList.remove('heatmap-visible');
                button.textContent = 'ğŸ”¥ æ˜¾ç¤ºçƒ­åŠ›å›¾';
                button.style.background = '#FF9800';
                debug('çƒ­åŠ›å›¾å·²éšè—');
            }
        }

        // ===========================================
        // çœ¼åŠ¨æ•°æ®ç›‘å¬å™¨
        // ===========================================
        
        function gazeDataCallback(data, elapsedTime) {
            rawGazeCount++;
            
            if (!isTracking) {
                return;
            }

            if (isStoring && data && data.x && data.y) {
                storedPoints.x.push(data.x);
                storedPoints.y.push(data.y);
            }
            
            let currentTime = Date.now();
            
            if (data == null || data.x < 0 || data.x > window.innerWidth || 
                data.y < 0 || data.y > window.innerHeight) {
                lastGazeTime = currentTime;
                return;
            }
            
            let timeDiff = currentTime - lastGazeTime;
            if (lastGazeTime > 0 && timeDiff > 16 && timeDiff < 1000) {
                let gazePoint = {
                    x: Math.floor(data.x),
                    y: Math.floor(data.y),
                    timestamp: new Date().toISOString(),
                    duration: timeDiff,
                    confidence: 0.8
                };
                
                if (lastGazePoint && detectSaccade(gazePoint, lastGazePoint)) {
                    const distance = Math.sqrt(
                        Math.pow(gazePoint.x - lastGazePoint.x, 2) + 
                        Math.pow(gazePoint.y - lastGazePoint.y, 2)
                    );
                    
                    const saccadeData = {
                        fromX: lastGazePoint.x,
                        fromY: lastGazePoint.y,
                        toX: gazePoint.x,
                        toY: gazePoint.y,
                        distance: Math.round(distance),
                        duration: timeDiff,
                        velocity: calculateSaccadeVelocity(distance, timeDiff),
                        timestamp: gazePoint.timestamp
                    };
                    
                    eyeTrackingData.saccades.push(saccadeData);
                    saccadeCount++;
                    document.getElementById('saccadeCount').textContent = saccadeCount;
                }
                
                processFixation(gazePoint);
                
                eyeTrackingData.gazePoints.push(gazePoint);
                
                if (heatmapInstance) {
                    const heatValue = Math.min(Math.max(timeDiff / 10, 1), 100);
                    heatmapInstance.addData({
                        x: gazePoint.x,
                        y: gazePoint.y,
                        value: heatValue
                    });
                }
                
                gazeCount++;
                document.getElementById('totalGazes').textContent = gazeCount;
                totalDuration += timeDiff;
                lastGazePoint = gazePoint;
                
                if (gazeCount % 50 === 0) {
                    debug(`æ•°æ®æ”¶é›†è¿›åº¦: ${gazeCount} æ³¨è§†ç‚¹, ${saccadeCount} çœ¼è·³, ${fixationCount} æ³¨è§†`);
                }
            }
            
            lastGazeTime = currentTime;
        }

        // ===========================================
        // ç²¾åº¦è®¡ç®—å‡½æ•°
        // ===========================================
        
        function store_points_variable() {
            isStoring = true;
            storedPoints = {x: [], y: []};
            debug('å¼€å§‹å­˜å‚¨é¢„æµ‹ç‚¹ç”¨äºç²¾åº¦è®¡ç®—');
        }

        function stop_storing_points_variable() {
            isStoring = false;
            debug(`åœæ­¢å­˜å‚¨é¢„æµ‹ç‚¹ï¼Œå…±æ”¶é›†åˆ° ${storedPoints.x.length} ä¸ªç‚¹`);
        }

        function getStoredPoints() {
            return [storedPoints.x, storedPoints.y];
        }

        function calculatePrecision(past50Array) {
            var windowHeight = window.innerHeight;
            var windowWidth = window.innerWidth;
            var x50 = past50Array[0];
            var y50 = past50Array[1];
            var staringPointX = windowWidth / 2;
            var staringPointY = windowHeight / 2;

            var precisionPercentages = new Array(Math.min(50, x50.length));
            calculatePrecisionPercentages(precisionPercentages, windowHeight, x50, y50, staringPointX, staringPointY);
            var precision = calculateAverage(precisionPercentages);

            return Math.round(precision);
        }

        function calculatePrecisionPercentages(precisionPercentages, windowHeight, x50, y50, staringPointX, staringPointY) {
            var pointCount = Math.min(50, x50.length);
            for (var x = 0; x < pointCount; x++) {
                var xDiff = staringPointX - x50[x];
                var yDiff = staringPointY - y50[x];
                var distance = Math.sqrt((xDiff * xDiff) + (yDiff * yDiff));
                var halfWindowHeight = windowHeight / 2;
                var precision = 0;
                if (distance <= halfWindowHeight && distance > -1) {
                    precision = 100 - (distance / halfWindowHeight * 100);
                } else if (distance > halfWindowHeight) {
                    precision = 0;
                } else if (distance > -1) {
                    precision = 100;
                }
                precisionPercentages[x] = precision;
            }
        }

        function calculateAverage(precisionPercentages) {
            var precision = 0;
            for (var x = 0; x < precisionPercentages.length; x++) {
                precision += precisionPercentages[x];
            }
            precision = precision / precisionPercentages.length;
            return precision;
        }

        // ===========================================
        // æ ¡å‡†å‡½æ•°
        // ===========================================
        
        function ClearCanvas(){
            document.querySelectorAll('.Calibration').forEach((i) => {
                i.style.setProperty('display', 'none');
            });
            var canvas = document.getElementById("plotting_canvas");
            canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
        }

        function PopUpInstruction(){
            ClearCanvas();
            swal({
                title:"æ ¡å‡†æç¤º",
                text: "è¯·ç‚¹å‡»å±å¹•ä¸Šçš„9ä¸ªçº¢ç‚¹è¿›è¡Œæ ¡å‡†ã€‚æ¯ä¸ªç‚¹éœ€è¦ç‚¹å‡»5æ¬¡ç›´åˆ°å˜é»„è‰²ã€‚è¿™å°†æé«˜çœ¼åŠ¨è¿½è¸ªç²¾åº¦ã€‚",
                buttons:{
                    cancel: false,
                    confirm: true
                }
            }).then(isConfirm => {
                ShowCalibrationPoint();
            });
        }

        function calPointClick(node) {
            const id = node.id;
            if (!CalibrationPoints[id]){ 
                CalibrationPoints[id]=0;
            }
            CalibrationPoints[id]++;

            if (CalibrationPoints[id]==5){ 
                node.style.setProperty('background-color', 'yellow');
                node.setAttribute('disabled', 'disabled');
                PointCalibrate++;
                debug(`æ ¡å‡†ç‚¹ ${id} å®Œæˆï¼Œå·²æ ¡å‡†ç‚¹æ•°: ${PointCalibrate}`);
            }else if (CalibrationPoints[id]<5){
                var opacity = 0.2*CalibrationPoints[id]+0.2;
                node.style.setProperty('opacity', opacity);
                debug(`æ ¡å‡†ç‚¹ ${id} ç‚¹å‡»æ¬¡æ•°: ${CalibrationPoints[id]}/5`);
            }

            if (PointCalibrate == 8){
                document.getElementById('Pt5').style.removeProperty('display');
                debug('æ˜¾ç¤ºä¸­é—´æ ¡å‡†ç‚¹ Pt5');
            }

            if (PointCalibrate >= 9){ 
                document.querySelectorAll('.Calibration').forEach((i) => {
                    i.style.setProperty('display', 'none');
                });
                document.getElementById('Pt5').style.removeProperty('display');
                var canvas = document.getElementById("plotting_canvas");
                canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
                calcAccuracy();
            }
        }

        function ShowCalibrationPoint() {
            document.querySelectorAll('.Calibration').forEach((i) => {
                i.style.removeProperty('display');
            });
            document.getElementById('Pt5').style.setProperty('display', 'none');
        }

        function ClearCalibration(){
            if (typeof webgazer !== 'undefined' && webgazer.clearData) {
                webgazer.clearData();
            }
            document.querySelectorAll('.Calibration').forEach((i) => {
                i.style.setProperty('background-color', 'red');
                i.style.setProperty('opacity', '0.2');
                i.removeAttribute('disabled');
            });
            CalibrationPoints = {};
            PointCalibrate = 0;
        }

        function sleep (time) {
            return new Promise((resolve) => setTimeout(resolve, time));
        }

        function Restart(){
            document.getElementById("Accuracy").innerHTML = "ç­‰å¾…æ ¡å‡†...";
            webgazer.clearData();
            ClearCalibration();
            PopUpInstruction();
        }

        function calcAccuracy() {
            swal({
                title: "æµ‹é‡ç²¾åº¦ä¸­",
                text: "è¯·ä¸è¦ç§»åŠ¨é¼ æ ‡ï¼Œå¹¶å‡è§†ä¸­é—´çš„ç‚¹5ç§’é’Ÿã€‚è¿™å°†å¸®åŠ©æˆ‘ä»¬è®¡ç®—é¢„æµ‹ç²¾åº¦ã€‚",
                closeOnEsc: false,
                allowOutsideClick: false,
                closeModal: true
            }).then( () => {
                debug('å¼€å§‹5ç§’ç²¾åº¦æµ‹é‡ï¼Œè¯·å‡è§†å±å¹•ä¸­å¿ƒ');
                store_points_variable();
                
                sleep(5000).then(() => {
                    stop_storing_points_variable();
                    var past50 = getStoredPoints();
                    
                    var precision_measurement = past50[0].length === 0 ? 50 : calculatePrecision(past50);
                    
                    var accuracyLabel = "ç²¾åº¦ | "+precision_measurement+"%";
                    document.getElementById("Accuracy").innerHTML = accuracyLabel;
                    debug(`ç²¾åº¦æµ‹é‡å®Œæˆ: ${precision_measurement}%`);
                    
                    swal({
                        title: "æ‚¨çš„ç²¾åº¦æµ‹é‡ç»“æœæ˜¯ " + precision_measurement + "%",
                        allowOutsideClick: false,
                        buttons: {
                            cancel: "é‡æ–°æ ¡å‡†",
                            confirm: "ç»§ç»­æ”¶é›†æ•°æ®",
                        }
                    }).then(isConfirm => {
                        if (isConfirm){
                            ClearCanvas();
                            updateStatus('æ ¡å‡†å®Œæˆ - æ•°æ®æ”¶é›†ä¸­', 'ready');
                            debug('æ ¡å‡†å®Œæˆï¼Œç»§ç»­æ•°æ®æ”¶é›†');
                        } else {
                            document.getElementById("Accuracy").innerHTML = "ç­‰å¾…æ ¡å‡†...";
                            webgazer.clearData();
                            ClearCalibration();
                            ClearCanvas();
                            ShowCalibrationPoint();
                        }
                    });
                });
            });
        }

        // ===========================================
        // ç³»ç»Ÿåˆå§‹åŒ–
        // ===========================================
        
        async function checkLibrariesLoaded() {
            updateStatus('æ£€æŸ¥åº“æ–‡ä»¶...', 'loading');
            updateLoadingProgress(25);
            
            if (typeof h337 === 'undefined') {
                try {
                    await new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/heatmap.js/2.0.0/heatmap.min.js';
                        script.onload = resolve;
                        script.onerror = reject;
                        document.head.appendChild(script);
                    });
                } catch (error) {
                    updateStatus('Heatmapåº“åŠ è½½å¤±è´¥', 'error');
                    document.getElementById('systemStatus').textContent = 'Heatmapç¼ºå¤±';
                    return false;
                }
            }
            
            updateLoadingProgress(50);
            
            if (typeof webgazer === 'undefined') {
                try {
                    const success = await loadWebGazerScript();
                    if (!success) {
                        throw new Error('WebGazeråŠ è½½å¤±è´¥');
                    }
                } catch (error) {
                    updateStatus('WebGazeråº“åŠ è½½å¤±è´¥', 'error');
                    document.getElementById('systemStatus').textContent = 'WebGazerç¼ºå¤±';
                    return false;
                }
            }
            
            updateLoadingProgress(75);
            setTimeout(testFirebaseConnection, 500);
            updateLoadingProgress(100);
            
            document.getElementById('systemStatus').textContent = 'å·²åŠ è½½';
            librariesLoaded = true;
            
            setTimeout(() => {
                document.getElementById('loadingBar').style.display = 'none';
            }, 500);
            
            return true;
        }

        function setupHeatmap() {
            try {
                heatmapInstance = h337.create({
                    container: document.getElementById('heatmapContainer'),
                    maxOpacity: 0.8,
                    minOpacity: 0.1,
                    blur: 0.85,
                    gradient: {
                        0.0: 'rgba(0, 0, 255, 0)',
                        0.2: 'rgba(0, 0, 255, 0.5)',
                        0.4: 'rgba(0, 255, 255, 0.7)',
                        0.6: 'rgba(0, 255, 0, 0.8)',
                        0.8: 'rgba(255, 255, 0, 0.9)',
                        1.0: 'rgba(255, 0, 0, 1.0)'
                    }
                });
                
                debug('çƒ­åŠ›å›¾åˆå§‹åŒ–å®Œæˆ');
                return true;
            } catch (error) {
                debug(`çƒ­åŠ›å›¾åˆå§‹åŒ–å¤±è´¥: ${error.message}`);
                return false;
            }
        }

        async function startEyeTracking() {
            if (!librariesLoaded) {
                alert('åº“æ–‡ä»¶è¿˜æœªåŠ è½½å®Œæˆï¼Œè¯·ç­‰å¾…ï¼');
                return;
            }
            
            document.getElementById('startBtn').disabled = true;
            document.getElementById('startBtn').textContent = 'ğŸ”„ åˆå§‹åŒ–ä¸­...';
            
            updateStatus('åˆå§‹åŒ– WebGazer...', 'initializing');
            document.getElementById('systemStatus').textContent = 'åˆå§‹åŒ–ä¸­';

            try {
                await webgazer.setRegression('ridge')
                    .setGazeListener(gazeDataCallback)
                    .saveDataAcrossSessions(true)
                    .begin();
                
                webgazer.showVideoPreview(true)
                        .showPredictionPoints(true)
                        .applyKalmanFilter(true);
                
                var canvas = document.getElementById("plotting_canvas");
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                canvas.style.position = 'fixed';
                
                setupCalibrationListeners();
                
                webgazerReady = true;
                isTracking = true;
                
                if (firebaseConnected) {
                    startAutoSave();
                }
                
                updateStatus('æ•°æ®æ”¶é›†ä¸­', 'ready');
                document.getElementById('systemStatus').textContent = 'æ”¶é›†ä¸­';
                document.getElementById('calibrateBtn').disabled = false;
                document.getElementById('startBtn').textContent = 'âœ… æ”¶é›†ä¸­';
                
                debug('çœ¼åŠ¨è¿½è¸ªå·²å¯åŠ¨ï¼Œå¼€å§‹æ”¶é›†å®Œæ•´æ•°æ®');
                
            } catch (error) {
                debug(`å¯åŠ¨å¤±è´¥: ${error.message}`);
                updateStatus('å¯åŠ¨å¤±è´¥', 'error');
                document.getElementById('systemStatus').textContent = 'å¯åŠ¨å¤±è´¥';
                document.getElementById('startBtn').disabled = false;
                document.getElementById('startBtn').textContent = 'ğŸ”„ é‡è¯•å¯åŠ¨';
            }
        }
        
        function setupCalibrationListeners() {
            document.querySelectorAll('.Calibration').forEach((i) => {
                i.addEventListener('click', () => {
                    calPointClick(i);
                });
            });
        }

        // ===========================================
        // å·¥å…·å‡½æ•°
        // ===========================================
        
        function updateStats() {
            let elapsedSeconds = (Date.now() - startTime) / 1000;
            document.getElementById('runningTime').textContent = Math.round(elapsedSeconds) + 'ç§’';
        }

        function updateStatus(message, type) {
            const statusElement = document.getElementById('status');
            statusElement.textContent = message;
            statusElement.className = `status ${type}`;
            debug(`çŠ¶æ€: ${message}`);
        }

        function debug(message) {
            const timestamp = new Date().toLocaleTimeString();
            console.log(`[${timestamp}] ${message}`);
            
            if (debugMode) {
                const debugDiv = document.getElementById('debugInfo');
                debugDiv.innerHTML = `[${timestamp}] ${message}<br>` + debugDiv.innerHTML;
                
                const lines = debugDiv.innerHTML.split('<br>');
                if (lines.length > 30) {
                    debugDiv.innerHTML = lines.slice(0, 30).join('<br>');
                }
            }
        }

        function toggleDebug() {
            debugMode = !debugMode;
            document.getElementById('debugPanel').style.display = debugMode ? 'block' : 'none';
            debug('è°ƒè¯•æ¨¡å¼åˆ‡æ¢: ' + (debugMode ? 'å¼€å¯' : 'å…³é—­'));
        }

        function updateLoadingProgress(percent) {
            const progressBar = document.getElementById('loadingBar');
            if (progressBar) {
                progressBar.style.width = percent + '%';
            }
        }

        function exportData() {
            const stats = {
                sessionId: sessionId,
                exportTime: new Date().toISOString(),
                user: userId,
                totalGazePoints: gazeCount,
                totalSaccades: saccadeCount,
                totalFixations: fixationCount,
                totalSnapshots: snapshotCount,
                averageFixationDuration: calculateAverageFixationDuration(),
                runningTime: Math.round((Date.now() - startTime) / 1000),
                calibrationPoints: PointCalibrate,
                systemReady: webgazerReady,
                firebaseConnected: firebaseConnected,
                accuracyMeasurement: document.getElementById("Accuracy").innerHTML,
                sessionStartTime: sessionStartTime,
                recentGazeData: eyeTrackingData.gazePoints,
                recentSaccadeData: eyeTrackingData.saccades,
                allFixationData: eyeTrackingData.fixations
            };
            
            const dataStr = JSON.stringify(stats, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `eye-tracking-export-${sessionId}.json`;
            link.click();
            
            URL.revokeObjectURL(url);
            debug(`æœ¬åœ°æ•°æ®å·²å¯¼å‡º`);
            alert(`ğŸ“Š æ•°æ®å¯¼å‡ºæˆåŠŸï¼\n\nåŒ…å«:\n- ${eyeTrackingData.gazePoints.length} ä¸ªæ³¨è§†ç‚¹\n- ${eyeTrackingData.saccades.length} ä¸ªçœ¼è·³\n- ${eyeTrackingData.fixations.length} ä¸ªæ³¨è§†è®°å½•\n- ${snapshotCount} ä¸ªäº‘ç«¯å¿«ç…§`);
        }

        function stopTracking() {
            isTracking = false;
            webgazerReady = false;
            isStoring = false;
            
            stopAutoSave();
            
            try {
                if (typeof webgazer !== 'undefined' && webgazer.isReady && webgazer.isReady()) {
                    webgazer.end();
                    debug('WebGazerå·²åœæ­¢');
                }
            } catch (error) {
                debug(`åœæ­¢WebGazeræ—¶å‡ºé”™: ${error.message}`);
            }
            
            updateStatus('æ•°æ®æ”¶é›†å·²åœæ­¢', 'error');
            document.getElementById('systemStatus').textContent = 'å·²åœæ­¢';
            document.getElementById('startBtn').disabled = false;
            document.getElementById('startBtn').textContent = 'ğŸš€ å¯åŠ¨çœ¼åŠ¨è¿½è¸ª';
            document.getElementById('calibrateBtn').disabled = true;
            
            ClearCalibration();
            ClearCanvas();
            
            debug('çœ¼åŠ¨è¿½è¸ªå·²åœæ­¢');
        }

        // ===========================================
        // é¡µé¢åˆå§‹åŒ–
        // ===========================================
        
        window.addEventListener('DOMContentLoaded', async function() {
            debug('é¡µé¢åŠ è½½å®Œæˆï¼Œå¼€å§‹ç³»ç»Ÿåˆå§‹åŒ–...');
            
            try {
                const loaded = await checkLibrariesLoaded();
                if
