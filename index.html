<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>眼动追踪热力图 - 官方标准版（真实精度计算）</title>
    <script>
        // 第三方Cookie警告
        window.addEventListener('DOMContentLoaded', function() {
            if (navigator.cookieEnabled && !document.cookie.includes('webgazer_cookie_consent')) {
                const cookieWarning = document.createElement('div');
                cookieWarning.style.cssText = 'position:fixed;top:0;left:0;width:100%;background:#ff9800;color:white;padding:12px;text-align:center;z-index:10000;font-weight:bold;';
                cookieWarning.innerHTML = '⚠️ 注意：WebGazer需要启用第三方Cookie才能正常工作。请确保您的浏览器设置允许第三方Cookie，或使用Chrome浏览器获得最佳体验。<button style="margin-left:15px;padding:5px 10px;background:white;border:none;border-radius:4px;cursor:pointer;">我知道了</button>';
                document.body.appendChild(cookieWarning);
                
                cookieWarning.querySelector('button').onclick = function() {
                    document.cookie = "webgazer_cookie_consent=true;max-age=31536000;path=/";
                    cookieWarning.style.display = 'none';
                };
            }
        });

        // 动态加载WebGazer
        async function loadWebGazerScript() {
            const sources = [
                './webgazer.js',  
                './lib/webgazer.js', 
                'https://webgazer.cs.brown.edu/webgazer.js',
                'https://unpkg.com/webgazer@2.0.2/dist/webgazer.js'
            ];

            for (const source of sources) {
                try {
                    await new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = source;
                        script.onload = resolve;
                        script.onerror = () => reject(new Error(`无法从 ${source} 加载WebGazer`));
                        document.head.appendChild(script);
                    });
                    console.log(`WebGazer从 ${source} 加载成功`);
                    return true;
                } catch (error) {
                    console.error(`尝试加载失败: ${error.message}`);
                }
            }
            return false;
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/heatmap.js/2.0.0/heatmap.min.js"></script>
    <!-- SweetAlert for popup messages (like in official calibration) -->
    <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            font-family: Arial, sans-serif;
            background: #f0f0f0;
        }
        
        /* 热力图容器 */
        #heatmapContainer { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            pointer-events: none; 
            z-index: 1000; 
        }
        
        /* 绘图画布 - 按照官方实现 */
        #plotting_canvas {
            position: fixed;
            top: 0;
            left: 0;
            cursor: crosshair;
            z-index: 900;
            pointer-events: none;
        }
        
        /* 页面内容 */
        #content { 
            position: relative; 
            z-index: 1; 
            padding: 50px; 
            max-width: 800px;
            margin: 0 auto;
            background: white;
            margin-top: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        /* 统计信息面板 */
        #statsPanel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.85);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 2000;
            min-width: 250px;
            font-size: 14px;
        }
        
        .stat-item {
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
        }
        
        .stat-value {
            font-weight: bold;
            color: #4CAF50;
        }
        
        /* 调试信息面板 */
        #debugPanel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.9);
            color: #00ff00;
            padding: 15px;
            border-radius: 8px;
            z-index: 2000;
            max-width: 300px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        /* 测试区域样式 */
        .test-area {
            height: 150px;
            margin: 30px 0;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #ddd;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .test-area:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .area-blue { background: linear-gradient(135deg, #74b9ff, #0984e3); color: white; }
        .area-green { background: linear-gradient(135deg, #00b894, #00a085); color: white; }
        .area-orange { background: linear-gradient(135deg, #fdcb6e, #e17055); color: white; }
        
        /* 控制按钮 */
        .controls {
            text-align: center;
            margin: 30px 0;
        }
        
        .btn {
            background: #4CAF50;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 0 10px;
            font-size: 16px;
            transition: background 0.3s;
        }
        
        .btn:hover { background: #45a049; }
        .btn.danger { background: #f44336; }
        .btn.danger:hover { background: #da190b; }
        .btn:disabled { background: #ccc; cursor: not-allowed; }
        
        /* 状态指示器 */
        .status {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 10px 15px;
            border-radius: 20px;
            font-weight: bold;
            z-index: 2000;
        }
        
        .status.ready { background: #4CAF50; color: white; }
        .status.calibrating { background: #ff9800; color: white; }
        .status.error { background: #f44336; color: white; }
        .status.initializing { background: #2196F3; color: white; }
        .status.loading { background: #9C27B0; color: white; }
        
        /* 加载进度条 */
        .loading-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 0%;
            height: 4px;
            background: linear-gradient(90deg, #4CAF50, #2196F3);
            z-index: 3000;
            transition: width 0.3s ease;
        }
        
        /* WebGazer视频预览样式调整 */
        #webgazerVideoContainer {
            position: fixed !important;
            top: 10px !important;
            right: 10px !important;
            z-index: 9999 !important;
            width: 240px !important;
            height: 180px !important;
        }
        
        #webgazerVideoFeed {
            width: 100% !important;
            height: 100% !important;
            border-radius: 8px !important;
            border: 2px solid #4CAF50 !important;
        }
        
        #webgazerFaceFeedbackBox {
            border: 2px solid #4CAF50 !important;
        }
        
        /* 校准点样式 - 使用响应式定位 */
        .Calibration {
            width: 20px;
            height: 20px;
            -webkit-border-radius: 25px;
            -moz-border-radius: 25px;
            border-radius: 25px;
            background-color: red;
            opacity: 0.2;
            border-color: black;
            border-style: solid;
            position: fixed;
            z-index: 99999;
            cursor: pointer;
        }
        
        /* 校准点位置 - 修复为响应式百分比定位 */
        /* 安全边距：距离边缘至少10%的距离 */
        #Pt1 { top: 10%; left: 10%; }         /* 左上角 */
        #Pt2 { top: 10%; left: 50%; margin-left: -10px; }  /* 上中 */
        #Pt3 { top: 10%; right: 10%; }        /* 右上角 */
        #Pt4 { top: 50%; margin-top: -10px; left: 10%; }   /* 左中 */
        #Pt5 { top: 50%; margin-top: -10px; left: 50%; margin-left: -10px; }  /* 中心 */
        #Pt6 { top: 50%; margin-top: -10px; right: 10%; }  /* 右中 */
        #Pt7 { bottom: 10%; left: 10%; }      /* 左下角 */
        #Pt8 { bottom: 10%; left: 50%; margin-left: -10px; }  /* 下中 */
        #Pt9 { bottom: 10%; right: 10%; }     /* 右下角 */
        
        /* 精度显示 */
        #Accuracy {
            background-color: #222;
            color: white;
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <!-- 加载进度条 -->
    <div id="loadingBar" class="loading-bar"></div>

    <!-- 状态指示器 -->
    <div id="status" class="status loading">正在加载库文件...</div>

    <!-- 绘图画布 - 按照官方实现 -->
    <canvas id="plotting_canvas" width="500" height="500"></canvas>

    <!-- 统计信息面板 -->
    <div id="statsPanel">
        <h3 style="margin-top: 0; color: #4CAF50;">📊 眼动数据统计</h3>
        <div class="stat-item">
            <span>注视点总数:</span>
            <span id="totalGazes" class="stat-value">0</span>
        </div>
        <div class="stat-item">
            <span>平均注视时长:</span>
            <span id="avgDuration" class="stat-value">0ms</span>
        </div>
        <div class="stat-item">
            <span>眼动频率:</span>
            <span id="gazeFrequency" class="stat-value">0 次/秒</span>
        </div>
        <div class="stat-item">
            <span>运行时间:</span>
            <span id="runningTime" class="stat-value">0秒</span>
        </div>
        <div id="Accuracy">等待校准...</div>
        <div class="stat-item">
            <span>WebGazer状态:</span>
            <span id="webgazerStatus" class="stat-value">加载中</span>
        </div>
        <div class="stat-item">
            <span>库加载状态:</span>
            <span id="libraryStatus" class="stat-value">加载中</span>
        </div>
    </div>

    <!-- 调试信息面板 -->
    <div id="debugPanel">
        <div id="debugInfo">调试信息将在这里显示...</div>
    </div>

    <!-- 热力图容器 -->
    <div id="heatmapContainer"></div>

    <!-- 校准点容器 - 按照官方HTML结构 -->
    <div class="calibrationDiv">
        <input type="button" class="Calibration" id="Pt1" style="display: none;">
        <input type="button" class="Calibration" id="Pt2" style="display: none;">
        <input type="button" class="Calibration" id="Pt3" style="display: none;">
        <input type="button" class="Calibration" id="Pt4" style="display: none;">
        <input type="button" class="Calibration" id="Pt5" style="display: none;">
        <input type="button" class="Calibration" id="Pt6" style="display: none;">
        <input type="button" class="Calibration" id="Pt7" style="display: none;">
        <input type="button" class="Calibration" id="Pt8" style="display: none;">
        <input type="button" class="Calibration" id="Pt9" style="display: none;">
    </div>

    <!-- 页面内容 -->
    <div id="content">
        <h1 style="text-align: center; color: #333;">🔥 眼动追踪热力图演示 - 官方标准版（真实精度计算）</h1>
        
        <div class="controls">
            <button class="btn" id="startBtn" onclick="startEyeTracking()">🚀 启动眼动追踪</button>
            <button class="btn" id="calibrateBtn" onclick="PopUpInstruction()" disabled>🎯 开始校准</button>
            <button class="btn" onclick="Restart()">🔄 重新校准</button>
            <button class="btn" onclick="clearHeatmap()">🧹 清除热力图</button>
            <button class="btn" onclick="exportData()">📊 导出数据</button>
            <button class="btn" onclick="toggleDebug()">🐛 切换调试</button>
            <button class="btn danger" onclick="stopTracking()">⏹️ 停止追踪</button>
        </div>
        
        <p style="text-align: center; font-size: 18px; color: #666;">
            👀 请看向下面的不同区域，系统会自动记录您的眼动轨迹并生成热力图
        </p>
        
        <div class="test-area area-blue">
            <h2>🌊 区域 A - 海洋蓝</h2>
            <p>这是第一个测试区域。请尝试注视这里几秒钟，观察热力图的变化。热力图会显示您注视时间最长的区域。</p>
        </div>
        
        <div class="test-area area-green">
            <h2>🌿 区域 B - 森林绿</h2>
            <p>这是第二个测试区域。您可以在不同区域之间移动视线，系统会实时记录您的眼动模式和注视时长。</p>
        </div>
        
        <div class="test-area area-orange">
            <h2>🔥 区域 C - 夕阳橙</h2>
            <p>这是第三个测试区域。长时间注视同一位置会在热力图上形成"热点"，颜色越红表示注视时间越长。</p>
        </div>
        
        <div style="background: white; padding: 20px; border-radius: 10px; margin-top: 30px; border-left: 4px solid #4CAF50;">
            <h3>📋 使用说明（官方标准版 - 真实精度计算）：</h3>
            <ol>
                <li><strong>点击"启动眼动追踪"</strong> - 首先启动系统</li>
                <li><strong>允许摄像头权限</strong> - 浏览器会询问摄像头权限</li>
                <li><strong>等待系统就绪</strong> - 观察左上角状态指示器</li>
                <li><strong>点击"开始校准"</strong> - 按照弹窗提示进行校准</li>
                <li><strong>依次点击9个校准点</strong> - 每个点需要点击5次，看向该点再点击</li>
                <li><strong>等待真实精度计算</strong> - 校准完成后会进行5秒的真实精度测量</li>
                <li><strong>自然地浏览页面</strong> - 看向不同区域，系统会自动记录</li>
                <li><strong>观察热力图</strong> - 红色区域表示注视时间长的地方</li>
            </ol>
            <p style="color: #e74c3c; margin-top: 15px;"><strong>新增功能：</strong> 现在使用真实的精度计算算法，基于WebGazer官方代码实现！</p>
            <p style="color: #27ae60; margin-top: 10px;"><strong>修复内容：</strong> 校准点现在使用响应式百分比定位，在所有屏幕尺寸下都能正确显示！</p>
        </div>
    </div>

    <script>
        // ===========================================
        // 全局变量定义 - 完全按照官方代码
        // ===========================================
        let heatmapInstance = null;
        let gazeCount = 0;
        let totalDuration = 0;
        let startTime = Date.now();
        let isTracking = false;
        let webgazerReady = false;
        let debugMode = true;
        let rawGazeCount = 0;
        let initializationAttempts = 0;
        let librariesLoaded = false;
        let lastGazeTime = 0;
        
        // 校准相关变量 - 按照官方代码
        var PointCalibrate = 0;
        var CalibrationPoints = {};

        // 精度计算相关变量 - 按照官方代码
        var isStoring = false;
        var storedPoints = {x: [], y: []};

        // ===========================================
        // 官方精度计算函数 - 完全复制自官方代码
        // ===========================================

        /**
         * 开始存储预测点 - 按照官方precision_store_points.js
         */
        function store_points_variable() {
            isStoring = true;
            storedPoints = {x: [], y: []};
            debug('开始存储预测点用于精度计算');
        }

        /**
         * 停止存储预测点 - 按照官方precision_store_points.js
         */
        function stop_storing_points_variable() {
            isStoring = false;
            debug(`停止存储预测点，共收集到 ${storedPoints.x.length} 个点`);
        }

        /**
         * 获取存储的点 - 按照官方precision_store_points.js
         */
        function getStoredPoints() {
            return [storedPoints.x, storedPoints.y];
        }

        /**
         * 计算精度 - 完全按照官方precision_calculation.js
         */
        function calculatePrecision(past50Array) {
            var windowHeight = window.innerHeight;
            var windowWidth = window.innerWidth;

            // Retrieve the last 50 gaze prediction points
            var x50 = past50Array[0];
            var y50 = past50Array[1];

            // Calculate the position of the point the user is staring at
            var staringPointX = windowWidth / 2;
            var staringPointY = windowHeight / 2;

            debug(`计算精度: 窗口尺寸 ${windowWidth}x${windowHeight}, 凝视点 (${staringPointX}, ${staringPointY}), 预测点数 ${x50.length}`);

            var precisionPercentages = new Array(Math.min(50, x50.length));
            calculatePrecisionPercentages(precisionPercentages, windowHeight, x50, y50, staringPointX, staringPointY);
            var precision = calculateAverage(precisionPercentages);

            debug(`精度计算完成: ${precision.toFixed(2)}%`);
            // Return the precision measurement as a rounded percentage
            return Math.round(precision);
        }

        /**
         * 计算每个预测点的精度百分比 - 按照官方precision_calculation.js
         */
        function calculatePrecisionPercentages(precisionPercentages, windowHeight, x50, y50, staringPointX, staringPointY) {
            var pointCount = Math.min(50, x50.length);
            for (var x = 0; x < pointCount; x++) {
                // Calculate distance between each prediction and staring point
                var xDiff = staringPointX - x50[x];
                var yDiff = staringPointY - y50[x];
                var distance = Math.sqrt((xDiff * xDiff) + (yDiff * yDiff));

                // Calculate precision percentage
                var halfWindowHeight = windowHeight / 2;
                var precision = 0;
                if (distance <= halfWindowHeight && distance > -1) {
                    precision = 100 - (distance / halfWindowHeight * 100);
                } else if (distance > halfWindowHeight) {
                    precision = 0;
                } else if (distance > -1) {
                    precision = 100;
                }

                // Store the precision
                precisionPercentages[x] = precision;
            }
        }

        /**
         * 计算平均精度 - 按照官方precision_calculation.js
         */
        function calculateAverage(precisionPercentages) {
            var precision = 0;
            for (var x = 0; x < precisionPercentages.length; x++) {
                precision += precisionPercentages[x];
            }
            precision = precision / precisionPercentages.length;
            return precision;
        }

        // ===========================================
        // 官方校准函数 - 完全复制自calibration.js
        // ===========================================
        
        /**
         * Clear the canvas and the calibration button.
         */
        function ClearCanvas(){
            document.querySelectorAll('.Calibration').forEach((i) => {
                i.style.setProperty('display', 'none');
            });
            var canvas = document.getElementById("plotting_canvas");
            canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
        }

        /**
         * Show the instruction of using calibration at the start up screen.
         */
        function PopUpInstruction(){
            ClearCanvas();
            swal({
                title:"Calibration",
                text: "Please click on each of the 9 points on the screen. You must click on each point 5 times till it goes yellow. This will calibrate your eye movements.",
                buttons:{
                    cancel: false,
                    confirm: true
                }
            }).then(isConfirm => {
                ShowCalibrationPoint();
            });
        }

        function calPointClick(node) {
            const id = node.id;

            if (!CalibrationPoints[id]){ // initialises if not done
                CalibrationPoints[id]=0;
            }
            CalibrationPoints[id]++; // increments values

            if (CalibrationPoints[id]==5){ //only turn to yellow after 5 clicks
                node.style.setProperty('background-color', 'yellow');
                node.setAttribute('disabled', 'disabled');
                PointCalibrate++;
                debug(`校准点 ${id} 完成，已校准点数: ${PointCalibrate}`);
            }else if (CalibrationPoints[id]<5){
                //Gradually increase the opacity of calibration points when click to give some indication to user.
                var opacity = 0.2*CalibrationPoints[id]+0.2;
                node.style.setProperty('opacity', opacity);
                debug(`校准点 ${id} 点击次数: ${CalibrationPoints[id]}/5`);
            }

            //Show the middle calibration point after all other points have been clicked.
            if (PointCalibrate == 8){
                document.getElementById('Pt5').style.removeProperty('display');
                debug('显示中间校准点 Pt5');
            }

            if (PointCalibrate >= 9){ // last point is calibrated
                // grab every element in Calibration class and hide them except the middle point.
                document.querySelectorAll('.Calibration').forEach((i) => {
                    i.style.setProperty('display', 'none');
                });
                document.getElementById('Pt5').style.removeProperty('display');

                // clears the canvas
                var canvas = document.getElementById("plotting_canvas");
                canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);

                // Calculate the accuracy
                calcAccuracy();
            }
        }

        /**
         * Show the Calibration Points
         */
        function ShowCalibrationPoint() {
            document.querySelectorAll('.Calibration').forEach((i) => {
                i.style.removeProperty('display');
            });
            // initially hides the middle button
            document.getElementById('Pt5').style.setProperty('display', 'none');
        }

        /**
         * This function clears the calibration buttons memory
         */
        function ClearCalibration(){
            // Clear data from WebGazer
            if (typeof webgazer !== 'undefined' && webgazer.clearData) {
                webgazer.clearData();
            }

            document.querySelectorAll('.Calibration').forEach((i) => {
                i.style.setProperty('background-color', 'red');
                i.style.setProperty('opacity', '0.2');
                i.removeAttribute('disabled');
            });

            CalibrationPoints = {};
            PointCalibrate = 0;
        }

        // sleep function
        function sleep (time) {
            return new Promise((resolve) => setTimeout(resolve, time));
        }

        /**
         * Restart the calibration process by clearing the local storage and reseting the calibration point
         */
        function Restart(){
            document.getElementById("Accuracy").innerHTML = "等待校准...";
            webgazer.clearData();
            ClearCalibration();
            PopUpInstruction();
        }

        /**
         * 真实精度计算 - 按照官方calibration.js实现
         */
        function calcAccuracy() {
            // show modal
            // notification for the measurement process
            swal({
                title: "Calculating measurement",
                text: "Please don't move your mouse & stare at the middle dot for the next 5 seconds. This will allow us to calculate the accuracy of our predictions.",
                closeOnEsc: false,
                allowOutsideClick: false,
                closeModal: true
            }).then( () => {
                debug('开始5秒精度测量，请凝视屏幕中心');
                // makes the variables true for 5 seconds & plots the points
                
                store_points_variable(); // start storing the prediction points
                
                sleep(5000).then(() => {
                    stop_storing_points_variable(); // stop storing the prediction points
                    var past50 = getStoredPoints(); // retrieve the stored points
                    
                    if (past50[0].length === 0) {
                        debug('警告：未收集到预测点，使用默认精度');
                        var precision_measurement = 50; // 默认精度
                    } else {
                        var precision_measurement = calculatePrecision(past50);
                    }
                    
                    var accuracyLabel = "Accuracy | "+precision_measurement+"%";
                    document.getElementById("Accuracy").innerHTML = accuracyLabel; // Show the accuracy in the nav bar.
                    debug(`精度测量完成: ${precision_measurement}%`);
                    
                    swal({
                        title: "Your accuracy measure is " + precision_measurement + "%",
                        allowOutsideClick: false,
                        buttons: {
                            cancel: "Recalibrate",
                            confirm: true,
                        }
                    }).then(isConfirm => {
                        if (isConfirm){
                            //clear the calibration & hide the last middle button
                            ClearCanvas();
                            updateStatus('校准完成 - 正在追踪', 'ready');
                        } else {
                            //use restart function to restart the calibration
                            document.getElementById("Accuracy").innerHTML = "等待校准...";
                            webgazer.clearData();
                            ClearCalibration();
                            ClearCanvas();
                            ShowCalibrationPoint();
                        }
                    });
                });
            });
        }

        // ===========================================
        // 库加载检查
        // ===========================================
        async function checkLibrariesLoaded() {
            updateStatus('检查库文件...', 'loading');
            updateLoadingProgress(25);
            
            if (typeof h337 === 'undefined') {
                debug('Heatmap库未加载，尝试再次加载...');
                try {
                    await new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/heatmap.js/2.0.0/heatmap.min.js';
                        script.onload = resolve;
                        script.onerror = reject;
                        document.head.appendChild(script);
                    });
                } catch (error) {
                    updateStatus('Heatmap库加载失败', 'error');
                    document.getElementById('libraryStatus').textContent = 'Heatmap缺失';
                    debug(`Heatmap加载错误: ${error.message}`);
                    return false;
                }
            }
            
            updateLoadingProgress(50);
            
            if (typeof webgazer === 'undefined') {
                debug('WebGazer库未加载，尝试再次加载...');
                try {
                    const success = await loadWebGazerScript();
                    if (!success) {
                        throw new Error('所有WebGazer源都加载失败');
                    }
                } catch (error) {
                    updateStatus('WebGazer库加载失败 - 请检查网络连接', 'error');
                    document.getElementById('libraryStatus').textContent = 'WebGazer缺失';
                    debug(`WebGazer加载错误: ${error.message}`);
                    
                    setTimeout(() => {
                        alert('WebGazer库加载失败!\n\n建议方案:\n1. 请检查网络连接\n2. 请访问 https://webgazer.cs.brown.edu/ 下载webgazer.js文件\n3. 将下载的文件放在同一文件夹中\n4. 刷新页面重试');
                    }, 500);
                    return false;
                }
            }
            
            if (typeof webgazer === 'undefined' || typeof h337 === 'undefined') {
                updateStatus('库加载异常', 'error');
                document.getElementById('libraryStatus').textContent = '加载失败';
                return false;
            }
            
            updateLoadingProgress(100);
            document.getElementById('libraryStatus').textContent = '已加载';
            librariesLoaded = true;
            
            setTimeout(() => {
                document.getElementById('loadingBar').style.display = 'none';
            }, 500);
            
            return true;
        }

        // ===========================================
        // 热力图初始化
        // ===========================================
        function setupHeatmap() {
            debug('初始化热力图...');
            
            try {
                heatmapInstance = h337.create({
                    container: document.getElementById('heatmapContainer'),
                    maxOpacity: 0.8,
                    minOpacity: 0.1,
                    blur: 0.85,
                    gradient: {
                        0.0: 'rgba(0, 0, 255, 0)',
                        0.2: 'rgba(0, 0, 255, 0.5)',
                        0.4: 'rgba(0, 255, 255, 0.7)',
                        0.6: 'rgba(0, 255, 0, 0.8)',
                        0.8: 'rgba(255, 255, 0, 0.9)',
                        1.0: 'rgba(255, 0, 0, 1.0)'
                    }
                });
                
                debug('热力图初始化完成');
                return true;
            } catch (error) {
                debug(`热力图初始化失败: ${error.message}`);
                return false;
            }
        }

        // ===========================================
        // 眼动数据监听器 - 增加了精度测量时的点存储
        // ===========================================
        function gazeDataCallback(data, elapsedTime) {
            rawGazeCount++;
            
            if (data == null || !isTracking) {
                return;
            }

            // 如果正在进行精度测量，存储预测点
            if (isStoring && data.x && data.y) {
                storedPoints.x.push(data.x);
                storedPoints.y.push(data.y);
            }
            
            let currentTime = Date.now();
            
            if (data.x < 0 || data.x > window.innerWidth || 
                data.y < 0 || data.y > window.innerHeight) {
                return;
            }
            
            let timeDiff = currentTime - lastGazeTime;
            if (lastGazeTime > 0 && timeDiff > 16 && timeDiff < 1000) {
                let point = {
                    x: Math.floor(data.x),
                    y: Math.floor(data.y),
                    value: Math.min(Math.max(timeDiff / 10, 1), 100)
                };
                
                heatmapInstance.addData(point);
                gazeCount++;
                totalDuration += timeDiff;
                
                if (gazeCount % 30 === 0) {
                    debug(`记录注视点: ${gazeCount}, 位置: (${point.x}, ${point.y}), 间隔: ${timeDiff}ms`);
                }
            }
            
            lastGazeTime = currentTime;
        }

        // ===========================================
        // WebGazer 初始化 - 按照官方main.js
        // ===========================================
        async function startEyeTracking() {
            if (!librariesLoaded) {
                alert('库文件还未加载完成，请等待加载完成后再试！');
                return;
            }
            
            initializationAttempts++;
            debug(`开始第 ${initializationAttempts} 次初始化尝试`);
            
            document.getElementById('startBtn').disabled = true;
            document.getElementById('startBtn').textContent = '🔄 初始化中...';
            
            updateStatus('初始化 WebGazer...', 'initializing');
            document.getElementById('webgazerStatus').textContent = '初始化中';

            try {
                // 按照官方main.js的方式初始化
                await webgazer.setRegression('ridge')
                    .setGazeListener(gazeDataCallback)
                    .saveDataAcrossSessions(true)
                    .begin();
                
                webgazer.showVideoPreview(true)
                        .showPredictionPoints(true)
                        .applyKalmanFilter(true);
                
                debug('WebGazer初始化完成，设置画布...');
                
                // 设置画布 - 按照官方setup函数
                var canvas = document.getElementById("plotting_canvas");
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                canvas.style.position = 'fixed';
                
                // 设置校准点击监听器
                setupCalibrationListeners();
                
                webgazerReady = true;
                isTracking = true;
                
                updateStatus('WebGazer就绪 - 请进行校准', 'ready');
                document.getElementById('webgazerStatus').textContent = '就绪';
                document.getElementById('calibrateBtn').disabled = false;
                document.getElementById('startBtn').textContent = '✅ 已启动';
                
                debug('WebGazer启动成功！');
                
                setTimeout(() => {
                    if (PointCalibrate === 0) {
                        alert('WebGazer已成功启动！\n\n为了获得准确的眼动追踪，请点击"开始校准"按钮进行9点校准。\n\n修复内容：校准点现在使用响应式定位，支持所有屏幕尺寸！');
                    }
                }, 2000);
                
            } catch (error) {
                debug(`WebGazer启动失败: ${error.message}`);
                updateStatus('启动失败 - 点击重试', 'error');
                document.getElementById('webgazerStatus').textContent = '启动失败';
                resetStartButton();
            }
        }
        
        /**
         * 设置校准点击监听器 - 按照官方代码
         */
        function setupCalibrationListeners() {
            document.querySelectorAll('.Calibration').forEach((i) => {
                i.addEventListener('click', () => {
                    calPointClick(i);
                });
            });
            debug('校准点击监听器已设置');
        }
        
        function resetStartButton() {
            document.getElementById('startBtn').disabled = false;
            document.getElementById('startBtn').textContent = '🔄 重试启动';
        }

        // ===========================================
        // 统计信息更新
        // ===========================================
        function updateStats() {
            document.getElementById('totalGazes').textContent = gazeCount;
            
            let avgDuration = gazeCount > 0 ? Math.round(totalDuration / gazeCount) : 0;
            document.getElementById('avgDuration').textContent = avgDuration + 'ms';

            let elapsedSeconds = (Date.now() - startTime) / 1000;
            let frequency = elapsedSeconds > 0 ? (gazeCount / elapsedSeconds).toFixed(2) : 0;
            document.getElementById('gazeFrequency').textContent = frequency + ' 次/秒';
            
            document.getElementById('runningTime').textContent = Math.round(elapsedSeconds) + '秒';
        }

        // ===========================================
        // 状态更新函数
        // ===========================================
        function updateStatus(message, type) {
            const statusElement = document.getElementById('status');
            statusElement.textContent = message;
            statusElement.className = `status ${type}`;
            debug(`状态更新: ${message}`);
        }

        // ===========================================
        // 页面初始化
        // ===========================================
        window.addEventListener('DOMContentLoaded', async function() {
            debug('页面加载完成，检查库文件...');
            
            try {
                const loaded = await checkLibrariesLoaded();
                if (!loaded) {
                    debug('库加载失败，无法继续初始化');
                    return;
                }
                
                debug('库文件加载成功，初始化热力图...');
                
                if (!setupHeatmap()) {
                    updateStatus('热力图初始化失败', 'error');
                    return;
                }
                
                updateStatus('点击启动按钮开始', 'ready');
                debug('系统准备就绪，等待用户启动');
                
                document.getElementById('startBtn').disabled = false;
            } catch (error) {
                debug(`初始化过程出错: ${error.message}`);
                updateStatus('初始化失败', 'error');
            }
        });

        // ===========================================
        // 调试函数
        // ===========================================
        function debug(message) {
            if (debugMode) {
                console.log(message);
                const debugDiv = document.getElementById('debugInfo');
                const timestamp = new Date().toLocaleTimeString();
                debugDiv.innerHTML = `[${timestamp}] ${message}<br>` + debugDiv.innerHTML;
                
                const lines = debugDiv.innerHTML.split('<br>');
                if (lines.length > 15) {
                    debugDiv.innerHTML = lines.slice(0, 15).join('<br>');
                }
            }
        }

        function toggleDebug() {
            debugMode = !debugMode;
            document.getElementById('debugPanel').style.display = debugMode ? 'block' : 'none';
            debug('调试模式切换: ' + (debugMode ? '开启' : '关闭'));
        }

        // ===========================================
        // 进度更新函数
        // ===========================================
        function updateLoadingProgress(percent) {
            const progressBar = document.getElementById('loadingBar');
            if (progressBar) {
                progressBar.style.width = percent + '%';
            }
        }

        // ===========================================
        // 其他功能函数
        // ===========================================
        function clearHeatmap() {
            if (heatmapInstance) {
                heatmapInstance.setData({data: [], max: 1000});
                gazeCount = 0;
                totalDuration = 0;
                startTime = Date.now();
                lastGazeTime = 0;
                updateStats();
                debug('热力图已清除，统计数据已重置');
            }
        }

        function exportData() {
            const stats = {
                totalGazePoints: gazeCount,
                rawGazeCount: rawGazeCount,
                averageDuration: gazeCount > 0 ? Math.round(totalDuration / gazeCount) : 0,
                gazeFrequency: ((Date.now() - startTime) / 1000 > 0) ? 
                    (gazeCount / ((Date.now() - startTime) / 1000)).toFixed(2) : 0,
                runningTime: Math.round((Date.now() - startTime) / 1000),
                calibrationPoints: PointCalibrate,
                webgazerReady: webgazerReady,
                initializationAttempts: initializationAttempts,
                librariesLoaded: librariesLoaded,
                accuracyMeasurement: document.getElementById("Accuracy").innerHTML,
                storedPointsCount: storedPoints.x.length,
                calibrationSystemFixed: true,
                responsiveCalibrationPoints: true,
                timestamp: new Date().toLocaleString('zh-CN')
            };
            
            const dataStr = JSON.stringify(stats, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `eye-tracking-data-fixed-${Date.now()}.json`;
            link.click();
            
            URL.revokeObjectURL(url);
            debug(`数据已导出: ${JSON.stringify(stats)}`);
            alert('数据导出成功！包含修复后的响应式校准系统数据');
        }

        function stopTracking() {
            isTracking = false;
            webgazerReady = false;
            isStoring = false;
            
            try {
                if (typeof webgazer !== 'undefined' && webgazer.isReady && webgazer.isReady()) {
                    webgazer.end();
                    debug('WebGazer已停止');
                }
            } catch (error) {
                debug(`停止WebGazer时出错: ${error.message}`);
            }
            
            updateStatus('追踪已停止', 'error');
            document.getElementById('webgazerStatus').textContent = '已停止';
            document.getElementById('startBtn').disabled = false;
            document.getElementById('startBtn').textContent = '🚀 启动眼动追踪';
            document.getElementById('calibrateBtn').disabled = true;
            
            ClearCalibration();
            ClearCanvas();
            
            debug('眼动追踪已停止，界面已重置');
        }

        // ===========================================
        // 页面卸载时清理资源 - 按照官方代码
        // ===========================================
        window.onbeforeunload = function() {
            if (typeof webgazer !== 'undefined') {
                webgazer.end();
                debug('页面卸载，WebGazer资源已清理');
            }
        }

        // ===========================================
        // 定时更新统计信息
        // ===========================================
        setInterval(updateStats, 1000);

        // ===========================================
        // 错误处理
        // ===========================================
        window.addEventListener('error', function(event) {
            debug(`全局错误: ${event.error?.message || event.message}`);
            console.error('页面错误:', event);
        });

        window.addEventListener('unhandledrejection', function(event) {
            debug(`未处理的Promise拒绝: ${event.reason}`);
            console.error('Promise错误:', event.reason);
        });
    </script>
</body>
</html>